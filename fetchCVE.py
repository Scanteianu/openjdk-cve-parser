#!/usr/bin/env python3

import argparse
import json
import requests
from bs4 import BeautifulSoup

parser = argparse.ArgumentParser(description='Scrape the OpenJDK CVE site and return it in JSON format.')

parser.add_argument('--date', type=str, default='2023-01-17', help='The date to scrape CVEs for (YYYY-MM-DD)')
parser.add_argument('--apikey', type=str, default=None, help='Your NVD API key')

args = parser.parse_args()

# fetch the CVEs for the given date
url = 'https://openjdk.org/groups/vulnerability/advisories/' + args.date
r = requests.get(url)

soup = BeautifulSoup(r.text, 'html.parser')

# find the table with the CVEs
table = soup.find('table', attrs={'class': 'risk-matrix'})

# find all the rows in the table
rows = table.find_all('tr')

jsonData = {
    'bomFormat': 'CycloneDX',
    'specVersion': '1.4',
    'version': 1,
    'vulnerabilities': [],
}
versions = []

# fetch CVE data from first td in each row
for row in rows:

    # find the versions in the first row
    header = row.find('th')
    if header is not None:
        component = header.find_next_sibling('th')
        if component.text == 'Component':
            score = component.find_next_sibling('th')
            while (score.find_next_sibling('th') is not None):
                versions.append(score.find_next_sibling('th').text)
                score = score.find_next_sibling('th')

    cve = row.find('td')
    if cve is not None:
        id = cve.text
        link = cve.find('a')['href']
        componentsTD = cve.find_next_sibling('td')
        components = componentsTD.text
        scoreTD = componentsTD.find_next_sibling('td')
        score = scoreTD.text

        affected_versions = []
        versionCheck = scoreTD
        
        for version in versions:
            versionCheck = versionCheck.find_next_sibling('td')
            if versionCheck.text == 'â€¢':
                affected_versions.append(version)

        # make an API call to get the additional data for the CVE
        cveURL = 'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=' + id
        # pass API key as a header if you have one
        if args.apikey:
            headers = {'apiKey': args.apikey}
            cveRequest = requests.get(cveURL, headers=headers)
        else:
            cveRequest = requests.get(cveURL)

        # check status code to see if we were rate limited
        if cveRequest.status_code != 200:
            print('Error fetching CVE data for ' + id)
            print('This is likely rate limiting')
            print('Status code: ' + str(cveRequest.status_code))
            exit(1)
        cveData = cveRequest.json()

        baseSeverity = cveData['vulnerabilities'][0]['cve']['metrics']['cvssMetricV31'][0]['cvssData']['baseSeverity'].lower()
        description = cveData['vulnerabilities'][0]['cve']['descriptions'][0]['value']
        published = cveData['vulnerabilities'][0]['cve']['published']

        source = {
            'name': 'National Vulnerability Database',
            'link': link
        }

        # create a dictionary for each CVE
        data = {
            'id': id,
            'source': source,
            'ratings': {
                'source': source,
                'method': 'CVSSv31',
                'score': float(score),
                'severity': baseSeverity
            },
            'description': description,
            'published': published,
            'affects': {
                'versions': {
                    'status': 'affected',
                    'versions': affected_versions
                }
            },
            'properties': {
                'name': 'Component',
                'value': components.replace('\n', ''),
            }
        }

        jsonData['vulnerabilities'].append(data)

# create a JSON file for each version
with open('releases/' + args.date + '.json', 'w') as f:
    json.dump(jsonData, f, indent=4)
