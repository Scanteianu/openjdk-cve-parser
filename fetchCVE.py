#!/usr/bin/env python3

import argparse
import json
import requests
from bs4 import BeautifulSoup

parser = argparse.ArgumentParser(description='Scrape the OpenJDK CVE site and return it in JSON format.')

parser.add_argument('--date', type=str, default='2023-01-17', help='The date to scrape CVEs for (YYYY-MM-DD)')

args = parser.parse_args()

# fetch the CVEs for the given date
url = 'https://openjdk.org/groups/vulnerability/advisories/' + args.date
r = requests.get(url)

soup = BeautifulSoup(r.text, 'html.parser')

# find the table with the CVEs
table = soup.find('table', attrs={'class': 'risk-matrix'})

# find all the rows in the table
rows = table.find_all('tr')

jsonData = []
versions = []

# fetch CVE data from first td in each row
for row in rows:

    # find the versions in the first row
    header = row.find('th')
    if header is not None:
        component = header.find_next_sibling('th')
        if component.text == 'Component':
            score = component.find_next_sibling('th')
            while (score.find_next_sibling('th') is not None):
                versions.append(score.find_next_sibling('th').text)
                score = score.find_next_sibling('th')

    cve = row.find('td')
    if cve is not None:
        id = cve.text
        link = cve.find('a')['href']
        componentsTD = cve.find_next_sibling('td')
        components = componentsTD.text
        scoreTD = componentsTD.find_next_sibling('td')
        score = scoreTD.text

        affected_versions = []
        versionCheck = scoreTD
        
        for version in versions:
            versionCheck = versionCheck.find_next_sibling('td')
            if versionCheck.text == 'â€¢':
                affected_versions.append(version)

        source = {
            'name': 'National Vulnerability Database',
            'link': link
        }

        # create a dictionary for each CVE
        data = {
            'bomFormat': 'CycloneDX',
            'specVersion': '1.4',
            'version': 1,
            'vulnerabilities': {
                'id': id,
            },
            'source': source,
            'properties': {
                'name': 'Component',
                'value': components.replace('\n', ''),
            },
            'ratings': {
                'source': source,
                'method': 'CVSSv31',
                'value': score
            },
            'affects': {
                'versions': {
                    'status': 'affected',
                    'versions': affected_versions
                }
            }
        }

        jsonData.append(data)

# create a JSON file for each version
with open('releases/' + args.date + '.json', 'w') as f:
    json.dump(jsonData, f, indent=4)
