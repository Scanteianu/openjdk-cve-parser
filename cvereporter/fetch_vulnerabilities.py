#!/usr/bin/env python3

import argparse
import json
import requests
from bs4 import BeautifulSoup
from datetime import datetime
from cyclonedx.model.impact_analysis import ImpactAnalysisAffectedStatus
from cyclonedx.model.vulnerability import Vulnerability, VulnerabilitySource,VulnerabilityScoreSource, VulnerabilityRating, VulnerabilitySeverity, BomTarget, BomTargetVersionRange

def fetch_cves(date: str)->list[Vulnerability]:
    cve_text = retrieve_cves_from_internet(date)
    return parse_to_cyclone(cve_text, date)

def retrieve_cves_from_internet(date: str) -> str:
    # fetch the CVEs for the given date
    url = 'https://openjdk.org/groups/vulnerability/advisories/' + date
    r = requests.get(url)

    resp_text = r.text
    # todo: make this configurable
    with open("data/open_jvg_dump_"+date+".html", "w") as dump:
        dump.write(resp_text)
    return resp_text

def parse_to_cyclone(resp_text: str, date: str) -> list[Vulnerability]:
    vulnerabilities = []
    soup = BeautifulSoup(resp_text, 'html.parser')

    # find the table with the CVEs
    table = soup.find('table', attrs={'class': 'risk-matrix'})

    # find all the rows in the table
    rows = table.find_all('tr')

    # fetch CVE data from first td in each row
    for row in rows:

        # find the versions in the first row
        header = row.find('th')
        versions = []
        if header is not None:
            component = header.find_next_sibling('th')
            if component.text == 'Component':
                score = component.find_next_sibling('th')
                while (score.find_next_sibling('th') is not None):
                    versions.append(score.find_next_sibling('th').text)
                    score = score.find_next_sibling('th')

        cve = row.find('td')
        if cve is not None:
            
            id = cve.text
            link = cve.find('a')['href']
            componentsTD = cve.find_next_sibling('td')
            component = componentsTD.text.replace('\n', '')
            scoreTD = componentsTD.find_next_sibling('td')
            score = scoreTD.text

            versionCheck = scoreTD
            affected_versions = []
            for version in versions:
                versionCheck = versionCheck.find_next_sibling('td')
                if versionCheck.text == 'â€¢':
                    affected_versions.append(int(version))

            affects = BomTarget(
                ref=component
            )
            for v in affected_versions:
                affects.versions.add(v)
            vuln = Vulnerability(
                id=id,
                source=VulnerabilitySource(name="National Vulnerability Database", url=link),
                #todo: dummy date
                published=datetime.fromisoformat(date),
                updated=datetime.fromisoformat(date),
                description="",
                recommendation=""
            )
            vuln.affects.add(affects)
            vulnerabilities.append(vuln)
            print(vuln)
    return vulnerabilities

# fetch_cves('2023-01-17')