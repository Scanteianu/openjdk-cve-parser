#!/usr/bin/env python3

import argparse
import json
import requests
from bs4 import BeautifulSoup
from datetime import datetime
from cyclonedx.model.impact_analysis import ImpactAnalysisAffectedStatus
from cyclonedx.model.vulnerability import Vulnerability, VulnerabilitySource,VulnerabilityScoreSource, VulnerabilityRating, VulnerabilitySeverity, BomTarget, BomTargetVersionRange

def fetch_cves(date: str)->list[Vulnerability]:
    cve_text = retrieve_cves_from_internet(date)
    return parse_to_cyclone(cve_text, date)

def retrieve_cves_from_internet(date: str) -> str:
    # fetch the CVEs for the given date
    url = 'https://openjdk.org/groups/vulnerability/advisories/' + date
    r = requests.get(url)

    resp_text = r.text
    # todo: make this configurable
    with open("data/open_jvg_dump_"+date+".html", "w") as dump:
        dump.write(resp_text)
    return resp_text

def parse_to_cyclone(resp_text: str, date: str) -> list[Vulnerability]:
    dicts = parse_to_dict(resp_text, date)
    return dict_to_vulns(dicts)
def parse_to_dict(resp_text: str, date: str) -> list[dict]:
    
    soup = BeautifulSoup(resp_text, 'html.parser')

    # find the table with the CVEs
    table = soup.find('table', attrs={'class': 'risk-matrix'})

    # find all the rows in the table
    rows = table.find_all('tr')
    dicts = []
    # fetch CVE data from first td in each row
    for row in rows:

        # find the versions in the first row
        header = row.find('th')
        versions = []
        if header is not None:
            component = header.find_next_sibling('th')
            if component.text == 'Component':
                score = component.find_next_sibling('th')
                while (score.find_next_sibling('th') is not None):
                    versions.append(score.find_next_sibling('th').text)
                    score = score.find_next_sibling('th')

        cve = row.find('td')
        if cve is not None:
            
            id = cve.text
            link = cve.find('a')['href']
            componentsTD = cve.find_next_sibling('td')
            component = componentsTD.text.replace('\n', '')
            scoreTD = componentsTD.find_next_sibling('td')
            score = scoreTD.text

            versionCheck = scoreTD
            affected_versions = []
            for version in versions:
                versionCheck = versionCheck.find_next_sibling('td')
                if versionCheck.text == 'â€¢':
                    affected_versions.append(int(version))

            
            parsed_data = {}
            parsed_data["id"] = id
            parsed_data["url"] = link
            parsed_data["date"] = date
            parsed_data["component"] = component
            parsed_data["affected"] = affected_versions
            print(json.dumps(parsed_data))
            dicts.append(parsed_data)
            
    return dicts
def dict_to_vulns(dicts: list[dict]) -> list[Vulnerability]:
    vulnerabilities = []
    for parsed_data in dicts:
        affects = BomTarget(
            ref=parsed_data["component"]
        )
        for v in parsed_data["affected"]:
            affects.versions.add(v)
        vuln = Vulnerability(
            id=parsed_data["id"],
            source=VulnerabilitySource(name="National Vulnerability Database", url=parsed_data["url"]),
            #todo: dummy date
            published=datetime.fromisoformat(parsed_data["date"]),
            updated=datetime.fromisoformat(parsed_data["date"]),
            description="",
            recommendation=""
        )
        vuln.affects.add(affects)
        vulnerabilities.append(vuln)
        print(vuln)
    return vulnerabilities

# fetch_cves('2023-01-17')